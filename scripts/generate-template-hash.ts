import { createHash } from "node:crypto";
import { existsSync, readdirSync, readFileSync, writeFileSync } from "node:fs";
import { resolve } from "node:path";
import { fileURLToPath } from "node:url";

export const ROOT_DIR = resolve(import.meta.dirname, "..");

/**
 * Generate theme-specific hashes from template and theme files for ETag versioning.
 * Each hash changes when any of the following files are modified:
 * - shared/templates/view.template.tsx
 * - public/themes/{theme}.css
 * - public/themes/{theme}.hljs.css
 */
export function generateTemplateHashes(): Record<string, string> {
	const templatePath = resolve(ROOT_DIR, "shared/templates/view.template.tsx");
	const templateContent = readFileSync(templatePath, "utf-8");

	const themesDir = resolve(ROOT_DIR, "public/themes");
	const themeNames = readdirSync(themesDir)
		.filter((file) => file.endsWith(".css") && !file.endsWith(".hljs.css"))
		.map((file) => file.replace(/\.css$/, ""))
		.sort();

	const hashes: Record<string, string> = {};

	for (const theme of themeNames) {
		const hash = createHash("md5");
		hash.update(templateContent);

		const themeCssPath = resolve(themesDir, `${theme}.css`);
		hash.update(readFileSync(themeCssPath, "utf-8"));

		const hljsCssPath = resolve(themesDir, `${theme}.hljs.css`);
		if (existsSync(hljsCssPath)) {
			hash.update(readFileSync(hljsCssPath, "utf-8"));
		}

		hashes[theme] = hash.digest("hex").slice(0, 5);
	}

	return hashes;
}

function main() {
	const templateHashes = generateTemplateHashes();
	const entries = Object.entries(templateHashes)
		.sort(([a], [b]) => a.localeCompare(b))
		.map(([theme, hash]) => `\t${theme}: "${hash}",`)
		.join("\n");

	const outputPath = resolve(
		ROOT_DIR,
		"shared/templates/template-hash.generated.ts",
	);
	const content = `// This file is auto-generated by scripts/generate-template-hash.ts
// Do not edit manually. Run "pnpm generate:hash" to regenerate.
export const TEMPLATE_HASH_BY_THEME = {
${entries}
} as const;

export function getTemplateHash(theme?: string): string {
	if (!theme) return TEMPLATE_HASH_BY_THEME.default;
	return (
		TEMPLATE_HASH_BY_THEME[theme as keyof typeof TEMPLATE_HASH_BY_THEME] ??
		TEMPLATE_HASH_BY_THEME.default
	);
}
`;

	writeFileSync(outputPath, content);
	console.log("âœ“ Generated template hashes:", templateHashes);
}

const isDirectExecution = (() => {
	const entryFromArgv = process.argv[1];
	if (!entryFromArgv) return false;
	return fileURLToPath(import.meta.url) === entryFromArgv;
})();

if (isDirectExecution) {
	main();
}
